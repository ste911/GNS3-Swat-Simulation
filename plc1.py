"""
swat-s1 plc1.py
"""


#from utils import PLC1_DATA, STATE, PLC1_PROTOCOL
#from utils import PLC_PERIOD_SEC, PLC_SAMPLES
#from utils import IP, LIT_101_M, LIT_301_M, FIT_201_THRESH,LS_201_M,LS_202_M,LS_203_M

import time
import logging
import cpppo
import subprocess
import shlex
from pwn import *
import string

HOST='192.168.1.1'
PORT=3001 

PLC1_TAGS = (
    ('FIT101', 1, 'REAL'),
    ('MV101', 1, 'INT'),
    ('LIT101', 1, 'REAL'),
    ('P101', 1, 'INT'),
    # interlocks does NOT go to the statedb
    ('FIT201', 1, 'REAL'),
    ('LS201', 1, 'REAL'),
    ('LS202', 1, 'REAL'),
    ('LS203', 1, 'REAL'),
    ('MV201', 1, 'INT'),
    ('LIT301', 1, 'REAL'),
)

LIT_101_M = {  # raw water tank m
    'LL': 0.250,
    'L': 0.400,
    'H': 0.800,
    'HH': 1.200,
}

LIT_301_M = {  # ultrafiltration tank m
    'LL': 0.250,
    'L': 0.400,
    'H': 1.000,
    'HH': 1.200,
}


LS_201_M = {  # ultrafiltration tank m
    'LL': 0.250,
    'L': 0.400,
    'H': 1.000,
    'HH': 1.200,
}

LS_202_M = {  # ultrafiltration tank m
    'LL': 0.250,
    'L': 0.400,
    'H': 1.000,
    'HH': 1.200,
}

LS_203_M = {  # ultrafiltration tank m
    'LL': 0.250,
    'L': 0.400,
    'H': 1.000,
    'HH': 1.200,
}
PLC1_ADDR = '192.168.1.10:44818'
PLC2_ADDR = '192.168.1.20:44818'
PLC3_ADDR = '192.168.1.30:44818'

PLC_PERIOD_SEC = 0.40  # plc update rate in seconds
PLC_PERIOD_HOURS = PLC_PERIOD_SEC / 3600.0
PLC_SAMPLES = 1000

PP_RESCALING_HOURS = 100
PP_PERIOD_SEC = 0.40  # physical process update rate in seconds
PP_PERIOD_HOURS = (PP_PERIOD_SEC / 3600.0) * PP_RESCALING_HOURS
PP_SAMPLES = int(PLC_PERIOD_SEC / PP_PERIOD_SEC) * PLC_SAMPLES

FIT101 = ('FIT101', 1)
MV101 = ('MV101', 1)
LIT101 = ('LIT101', 1)
P101 = ('P101', 1)
# interlocks to be received from plc2 and plc3
#LIT301_1 = ('LIT301', 1)    # to be sent
LIT301_3 = ('LIT301', 3)    # to be received
#FIT201_1 = ('FIT201', 1)    # to be sent
FIT201_2 = ('FIT201', 2)    # to be received
#LS201_1 = ('LS201', 1)      # to be sent
LS201_2 = ('LS201', 2)      # to be received
#LS202_1 = ('LS202', 1)      # to be sent
LS202_2 = ('LS202', 2)      # to be received
#LS203_1 = ('LS203', 1)      # to be sent
LS203_2 = ('LS203', 2)      # to be received
#MV201_1 = ('MV201', 1)      # to be sent
MV201_2 = ('MV201', 2)      # to be received
# SPHINX_SWAT_TUTORIAL PLC1 LOGIC)

# TODO: real value tag where to read/write flow sensor
class SwatPLC1():
    def __init__(self):

        try:
            self.server = self.start_server()
            #self.server.wait()
            time.sleep(10)
            self.pre_loop()
            print('pre_loop end')
            self.main_loop()
        except Exception as e:
            print(e)
            self.stop_server()

        self.stop_server()

    def start_server(self):
        """Start a cpppo enip server.

        The command used to start the server is generated by
        ``_start_server_cmd``.

        Notice that the client has to manage the new process,
        eg:kill it after use.

        :address: to serve
        :tags: to serve
        """

        try:
           CMD = 'python3 -m cpppo.server.enip '
           PRINT_Stdout = '--print '
           ADDRESS = '--address 192.168.1.10:44818 '
           TAGS=''
           for tag in PLC1_TAGS:
                 TAGS+=str(tag[0])
                 for field in tag[1:-1]:
                    TAGS+= ':' +str(field)

                 TAGS+='='
                 TAGS+=str(tag[-1])
                 TAGS+= ' '
           cmd = shlex.split( CMD+ PRINT_Stdout + ADDRESS +TAGS)
           # cmd = EnipProtocol._start_server_cmd(address, tags)
           server = subprocess.Popen(cmd, shell=False)
           return server

        except Exception as error:
            print ('ERROR enip _start_server: ', error)

    def stop_server(self):
        try:
           self.server.kill()
           print('Enip server killed')

        except Exception as error:
             print("Error in stopping enip server: ",error)

    def set (self, field, val):
      msg = 'SET:'
      msg+= field[0]+':'
      msg+= str(field[1])+':'
      msg += str(val)
      server = remote(HOST, PORT)
      server.send(msg.encode())
      server.close()
      return val

    def get (self, field):
      msg = 'GET:'
      msg+= field[0]+':'
      msg+= str(field[1])+':'
      server = remote(HOST, PORT)
      server.send(msg.encode())
      resp = server.recv(1024)
      server.close()
      return resp


    def send(self, what, value, address, **kwargs):
        """Send (write) a value to another host.

        It is a blocking operation the parent process will wait till the child
        cpppo process returns.

        :what: tuple addressing what
        :value: sent
        :address: ip[:port]
        """


        tag_string = ''
        tag_string += str(what[0])

        if len(what) >1:
          for field in what[1:]:
            tag_string += ':'
            tag_string += str(field)

        if value is not None:
           tag_string+= '='
           tag_string+= str(value)

        # print 'DEBUG enip _send tag_string: ', tag_string

        cmd = shlex.split(
            'python3 -m cpppo.server.enip.client ' +
            #'--log ' + self._client_log +
            '--address ' + address +
            ' ' + tag_string
        )
        # print 'DEBUG enip _send cmd shlex list: ', cmd

        # TODO: pipe stdout and return the sent value
        try:
            client = subprocess.Popen(cmd, shell=False)
            client.wait()

        except Exception as error:
            logging.debug('Exeption error %s', str(error))
            print ('ERROR enip _send: ', error)

    def receive(self, what, address, **kwargs):
        """Receive (read) a value from another host.

        It is a blocking operation the parent process will wait till the child
        cpppo process returns.

        :what: to ask for
        :address: to receive from

        :returns: tag value as a `str`
        """

        tag_string = ''
        tag_string += str(what[0])

        if len(what) >1:
          for field in what[1:]:
            tag_string += ':'
            tag_string += str(field)

        cmd = shlex.split(
            'python3 -m cpppo.server.enip.client ' + '--print ' +
   #         '--log ' + self._client_log +
            '--address ' + address +
            ' ' + tag_string
        )
        # print 'DEBUG enip _receive cmd shlex list: ', cmd

        try:
            client = subprocess.Popen(cmd, shell=False,
                stdout=subprocess.PIPE)

            # client.communicate is blocking
            raw_out = client.communicate()
            # print 'DEBUG enip _receive raw_out: ', raw_out

            # value is stored as first tuple element
            # between a pair of square brackets
            raw_string = raw_out[0]
            out = raw_string[(raw_string.find(b'[') + 1):raw_string.find(b']')]

            return out

        except Exception as error:
            print ('ERROR enip _receive: ', error)

    def pre_loop(self, sleep=0.2):
       # print 'DEBUG: swat-s1 plc1 enters pre_loop'
        #logging.basicConfig(filename='logs/plc1log.log', encoding ='utf-8', level=logging.DEBUG, filemode = 'w', format='%(asctime)s %(levelname)-8s %(message)s')
        time.sleep(sleep)

    def main_loop(self):
        """plc1 main loop.

            - reads sensors value
            - drives actuators according to the control strategy
            - updates its enip server
        """

#        print 'DEBUG: swat-s1 plc1 enters main_loop.'

        count = 0
        while(count <= PLC_SAMPLES):
            #logging.debug('plc 1 count : %d', count)
            lit101 = float(self.get(LIT101))
            print('lit101',lit101)
            #logging.debug('plc1 lit101: %.5f',lit101)
            self.send(LIT101, lit101, PLC1_ADDR)
            if lit101 >= LIT_101_M['HH']:
               # logging.warning("PLC1 - lit101 over HH: %.2f >= %.2f.",
                    # lit101, LIT_101_M['HH'])   
                self.set(MV101, 0)
                self.send(MV101, 0, PLC1_ADDR)

            elif lit101 >= LIT_101_M['H']:
                # CLOSE mv101
                #logging.info('PLC1 - lit101 over H -> close mv101')
                self.set(MV101, 0)
                self.send(MV101, 0, PLC1_ADDR)
            if lit101 <= LIT_101_M['LL']:
               # OPEN mv101
                #logging.warning("PLC1 - lit101 under LL: %.2f <= %.2f.", 
                       # lit101, LIT_101_M['LL'])
                self.set(MV101, 1)
                self.send(MV101, 1, PLC1_ADDR)
            elif lit101 <= LIT_101_M['L']:
                # OPEN mv101
                #logging.info("PLC1 - lit101 under L -> open mv101.")
                self.set(MV101, 1)
                self.send(MV101, 1, PLC1_ADDR)
                self.set(P101, 0)
                self.send(P101, 0, PLC1_ADDR)
            time.sleep(PLC_PERIOD_SEC)
            count += 1



            # TODO: use it when implement raw water tank
            # read from PLC2 (constant value)
            fit201 = float(self.receive(FIT201_2, PLC2_ADDR))
            #logging.debug("PLC1 - receive fit201: %f", fit201)
            #self.send(FIT201_1, fit201, PLC1_ADDR)

            ls201 = float(self.receive(LS201_2, PLC2_ADDR))
            #logging.debug("PLC1 - receive LS201: %f", ls201)
            #self.send(LS201_1, ls201, PLC1_ADDR)

            ls202 = float(self.receive(LS202_2, PLC2_ADDR))
            #logging.debug("PLC1 - receive LS202: %f", ls202)
            #self.send(LS202_1, ls202, PLC1_ADDR)

            ls203 = float(self.receive(LS203_2, PLC2_ADDR))
            #logging.debug("PLC1 - receive LS203: %f", ls203)
            #self.send(LS203_1, ls203, PLC1_ADDR)

            # # read from PLC3
            lit301 = float(self.receive(LIT301_3, PLC3_ADDR))
            #logging.debug("PLC1 - receive LIT301: %f", lit301)
            #self.send(LIT301_1, lit301, PLC1_ADDR)

            if lit301 <= LIT_301_M['L'] and lit101 >= LIT_101_M['L'] and ls201 >= LS_201_M['L'] \
                   and ls202 >= LS_202_M['L'] and ls203 >= LS_203_M['L'] :
                 # OPEN p101
                 #logging.info("PLC1 - lit301 under LIT_301_M['L'] -> open p101.")
                 self.set(P101, 1)
                 self.send(P101, 1, PLC1_ADDR)
            
            else:
                 # CLOSE p101
                 #logging.info("PLC1 - fit201 under FIT_201_THRESH " \
                  #     "or over LIT_301_M['H']: -> close p101.")
                 self.set(P101, 0)
                 self.send(P101, 0, PLC1_ADDR)

            time.sleep(PLC_PERIOD_SEC)
            count += 1
        #logging.debug('Swat PLC1 shutdown')

if __name__ == "__main__":

    # notice that memory init is different form disk init
    plc1 = SwatPLC1()
        #name='plc1',
        #state=STATE,
        #protocol=PLC1_PROTOCOL,
        #memory=PLC1_DATA,
        #disk=PLC1_DATA)
